procBlock.cpp: In member function ‘void procBlock::AssignGhostCellsGeom()’:
procBlock.cpp:2309:31: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2Move = dist2Move * 2.0;
                               ^
procBlock.cpp:2309:31: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2309:33: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2309:33: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2309:33: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
procBlock.cpp:2310:33: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2MoveJ = dist2MoveJ * 2.0;
                                 ^
procBlock.cpp:2310:33: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2310:35: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2MoveJ = dist2MoveJ * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2310:35: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2MoveJ = dist2MoveJ * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2310:35: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2MoveJ = dist2MoveJ * 2.0;
                                   ^
procBlock.cpp:2311:33: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2MoveK = dist2MoveK * 2.0;
                                 ^
procBlock.cpp:2311:33: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2311:35: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2MoveK = dist2MoveK * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2311:35: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2MoveK = dist2MoveK * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2311:35: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2MoveK = dist2MoveK * 2.0;
                                   ^
procBlock.cpp:2424:31: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2Move = dist2Move * 2.0;
                               ^
procBlock.cpp:2424:31: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2424:33: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2424:33: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2424:33: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
procBlock.cpp:2425:33: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2MoveI = dist2MoveI * 2.0;
                                 ^
procBlock.cpp:2425:33: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2425:35: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2MoveI = dist2MoveI * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2425:35: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2MoveI = dist2MoveI * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2425:35: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2MoveI = dist2MoveI * 2.0;
                                   ^
procBlock.cpp:2426:33: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2MoveK = dist2MoveK * 2.0;
                                 ^
procBlock.cpp:2426:33: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2426:35: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2MoveK = dist2MoveK * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2426:35: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2MoveK = dist2MoveK * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2426:35: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2MoveK = dist2MoveK * 2.0;
                                   ^
procBlock.cpp:2539:31: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2Move = dist2Move * 2.0;
                               ^
procBlock.cpp:2539:31: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2539:33: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2539:33: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2539:33: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2Move = dist2Move * 2.0;
                                 ^
procBlock.cpp:2540:33: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2MoveI = dist2MoveI * 2.0;
                                 ^
procBlock.cpp:2540:33: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2540:35: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2MoveI = dist2MoveI * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2540:35: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2MoveI = dist2MoveI * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2540:35: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2MoveI = dist2MoveI * 2.0;
                                   ^
procBlock.cpp:2541:33: error: no match for ‘operator*’ (operand types are ‘multiArray3d<vector3d<double> >’ and ‘double’)
         dist2MoveJ = dist2MoveJ * 2.0;
                                 ^
procBlock.cpp:2541:33: note: candidates are:
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp:140:17: note: multiArray3d<T> multiArray3d<T>::operator*(const T&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const T &factor) const {
                 ^
multiArray3d.hpp:140:17: note:   no known conversion for argument 1 from ‘double’ to ‘const vector3d<double>&’
multiArray3d.hpp:180:17: note: multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T>&) const [with T = vector3d<double>]
 multiArray3d<T> multiArray3d<T>::operator*(const multiArray3d<T> &b) const {
                 ^
multiArray3d.hpp:180:17: note:   no known conversion for argument 1 from ‘double’ to ‘const multiArray3d<vector3d<double> >&’
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2541:35: note:   mismatched types ‘const tensor<T>’ and ‘double’
         dist2MoveJ = dist2MoveJ * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2541:35: note:   mismatched types ‘const unitVec3dMag<T>’ and ‘double’
         dist2MoveJ = dist2MoveJ * 2.0;
                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2541:35: note:   mismatched types ‘const vector3d<T>’ and ‘double’
         dist2MoveJ = dist2MoveJ * 2.0;
                                   ^
procBlock.cpp: In member function ‘void procBlock::AssignGhostCellsGeomEdge()’:
procBlock.cpp:2643:53: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<double>’)
     vol_.Insert(imin, imax, jg1, jg1, kg1, kg1, 0.5 *
                                                     ^
procBlock.cpp:2643:53: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2645:58: note:   ‘multiArray3d<double>’ is not derived from ‘const tensor<T>’
                  vol_.Slice(imin, imax, jg1, jg1, kp, kp)));
                                                          ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2645:58: note:   ‘multiArray3d<double>’ is not derived from ‘const unitVec3dMag<T>’
                  vol_.Slice(imin, imax, jg1, jg1, kp, kp)));
                                                          ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2645:58: note:   ‘multiArray3d<double>’ is not derived from ‘const vector3d<T>’
                  vol_.Slice(imin, imax, jg1, jg1, kp, kp)));
                                                          ^
procBlock.cpp:2650:53: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<double>’)
     vol_.Insert(imin, imax, jg2, jg2, kg2, kg2, 0.5 *
                                                     ^
procBlock.cpp:2650:53: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2652:60: note:   ‘multiArray3d<double>’ is not derived from ‘const tensor<T>’
                  vol_.Slice(imin, imax, jg2, jg2, kg1, kg1)));
                                                            ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2652:60: note:   ‘multiArray3d<double>’ is not derived from ‘const unitVec3dMag<T>’
                  vol_.Slice(imin, imax, jg2, jg2, kg1, kg1)));
                                                            ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2652:60: note:   ‘multiArray3d<double>’ is not derived from ‘const vector3d<T>’
                  vol_.Slice(imin, imax, jg2, jg2, kg1, kg1)));
                                                            ^
procBlock.cpp:2655:57: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaI_.Insert(imin, imaxF, jg1, jg1, kg1, kg1, 0.5 *
                                                         ^
procBlock.cpp:2655:57: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2657:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaI_.Slice(imin, imaxF, jg1, jg1, kp, kp)));
                                                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2657:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaI_.Slice(imin, imaxF, jg1, jg1, kp, kp)));
                                                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2657:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaI_.Slice(imin, imaxF, jg1, jg1, kp, kp)));
                                                                 ^
procBlock.cpp:2658:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaJ_.Insert(imin, imax, jg1F, jg1F, kg1, kg1, 0.5 *
                                                          ^
procBlock.cpp:2658:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2660:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaJ_.Slice(imin, imax, jg1F, jg1F, kp, kp)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2660:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaJ_.Slice(imin, imax, jg1F, jg1F, kp, kp)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2660:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaJ_.Slice(imin, imax, jg1F, jg1F, kp, kp)));
                                                                  ^
procBlock.cpp:2661:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaK_.Insert(imin, imax, jg1, jg1, kg1F, kg1F, 0.5 *
                                                          ^
procBlock.cpp:2661:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2663:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaK_.Slice(imin, imax, jg1, jg1, kpF, kpF)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2663:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaK_.Slice(imin, imax, jg1, jg1, kpF, kpF)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2663:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaK_.Slice(imin, imax, jg1, jg1, kpF, kpF)));
                                                                  ^
procBlock.cpp:2679:57: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaI_.Insert(imin, imaxF, jg2, jg2, kg2, kg2, 0.5 *
                                                         ^
procBlock.cpp:2679:57: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2681:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaI_.Slice(imin, imaxF, jg2, jg2, kg1, kg1)));
                                                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2681:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaI_.Slice(imin, imaxF, jg2, jg2, kg1, kg1)));
                                                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2681:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaI_.Slice(imin, imaxF, jg2, jg2, kg1, kg1)));
                                                                   ^
procBlock.cpp:2682:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaJ_.Insert(imin, imax, jg2F, jg2F, kg2, kg2, 0.5 *
                                                          ^
procBlock.cpp:2682:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2684:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaJ_.Slice(imin, imax, jg2F, jg2F, kg1, kg1)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2684:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaJ_.Slice(imin, imax, jg2F, jg2F, kg1, kg1)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2684:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaJ_.Slice(imin, imax, jg2F, jg2F, kg1, kg1)));
                                                                    ^
procBlock.cpp:2685:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaK_.Insert(imin, imax, jg2, jg2, kg2F, kg2F, 0.5 *
                                                          ^
procBlock.cpp:2685:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2687:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaK_.Slice(imin, imax, jg2, jg2, kg1F, kg1F)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2687:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaK_.Slice(imin, imax, jg2, jg2, kg1F, kg1F)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2687:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaK_.Slice(imin, imax, jg2, jg2, kg1F, kg1F)));
                                                                    ^
procBlock.cpp:2773:53: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<double>’)
     vol_.Insert(ig1, ig1, jmin, jmax, kg1, kg1, 0.5 *
                                                     ^
procBlock.cpp:2773:53: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2775:58: note:   ‘multiArray3d<double>’ is not derived from ‘const tensor<T>’
                  vol_.Slice(ig1, ig1, jmin, jmax, kp, kp)));
                                                          ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2775:58: note:   ‘multiArray3d<double>’ is not derived from ‘const unitVec3dMag<T>’
                  vol_.Slice(ig1, ig1, jmin, jmax, kp, kp)));
                                                          ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2775:58: note:   ‘multiArray3d<double>’ is not derived from ‘const vector3d<T>’
                  vol_.Slice(ig1, ig1, jmin, jmax, kp, kp)));
                                                          ^
procBlock.cpp:2780:53: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<double>’)
     vol_.Insert(ig2, ig2, jmin, jmax, kg2, kg2, 0.5 *
                                                     ^
procBlock.cpp:2780:53: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2782:60: note:   ‘multiArray3d<double>’ is not derived from ‘const tensor<T>’
                  vol_.Slice(ig2, ig2, jmin, jmax, kg1, kg1)));
                                                            ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2782:60: note:   ‘multiArray3d<double>’ is not derived from ‘const unitVec3dMag<T>’
                  vol_.Slice(ig2, ig2, jmin, jmax, kg1, kg1)));
                                                            ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2782:60: note:   ‘multiArray3d<double>’ is not derived from ‘const vector3d<T>’
                  vol_.Slice(ig2, ig2, jmin, jmax, kg1, kg1)));
                                                            ^
procBlock.cpp:2785:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaI_.Insert(ig1F, ig1F, jmin, jmax, kg1, kg1, 0.5 *
                                                          ^
procBlock.cpp:2785:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2787:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaI_.Slice(ig1F, ig1F, jmin, jmax, kp, kp)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2787:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaI_.Slice(ig1F, ig1F, jmin, jmax, kp, kp)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2787:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaI_.Slice(ig1F, ig1F, jmin, jmax, kp, kp)));
                                                                  ^
procBlock.cpp:2788:57: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaJ_.Insert(ig1, ig1, jmin, jmaxF, kg1, kg1, 0.5 *
                                                         ^
procBlock.cpp:2788:57: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2790:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaJ_.Slice(ig1, ig1, jmin, jmaxF, kp, kp)));
                                                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2790:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaJ_.Slice(ig1, ig1, jmin, jmaxF, kp, kp)));
                                                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2790:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaJ_.Slice(ig1, ig1, jmin, jmaxF, kp, kp)));
                                                                 ^
procBlock.cpp:2791:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaK_.Insert(ig1, ig1, jmin, jmax, kg1F, kg1F, 0.5 *
                                                          ^
procBlock.cpp:2791:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2793:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaK_.Slice(ig1, ig1, jmin, jmax, kpF, kpF)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2793:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaK_.Slice(ig1, ig1, jmin, jmax, kpF, kpF)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2793:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaK_.Slice(ig1, ig1, jmin, jmax, kpF, kpF)));
                                                                  ^
procBlock.cpp:2809:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaI_.Insert(ig2F, ig2F, jmin, jmax, kg2, kg2, 0.5 *
                                                          ^
procBlock.cpp:2809:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2811:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaI_.Slice(ig2F, ig2F, jmin, jmax, kg1, kg1)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2811:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaI_.Slice(ig2F, ig2F, jmin, jmax, kg1, kg1)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2811:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaI_.Slice(ig2F, ig2F, jmin, jmax, kg1, kg1)));
                                                                    ^
procBlock.cpp:2812:57: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaJ_.Insert(ig2, ig2, jmin, jmaxF, kg2, kg2, 0.5 *
                                                         ^
procBlock.cpp:2812:57: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2814:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaJ_.Slice(ig2, ig2, jmin, jmaxF, kg1, kg1)));
                                                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2814:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaJ_.Slice(ig2, ig2, jmin, jmaxF, kg1, kg1)));
                                                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2814:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaJ_.Slice(ig2, ig2, jmin, jmaxF, kg1, kg1)));
                                                                   ^
procBlock.cpp:2815:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaK_.Insert(ig2, ig2, jmin, jmax, kg2F, kg2F, 0.5 *
                                                          ^
procBlock.cpp:2815:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2817:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaK_.Slice(ig2, ig2, jmin, jmax, kg1F, kg1F)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2817:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaK_.Slice(ig2, ig2, jmin, jmax, kg1F, kg1F)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2817:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaK_.Slice(ig2, ig2, jmin, jmax, kg1F, kg1F)));
                                                                    ^
procBlock.cpp:2903:53: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<double>’)
     vol_.Insert(ig1, ig1, jg1, jg1, kmin, kmax, 0.5 *
                                                     ^
procBlock.cpp:2903:53: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2905:58: note:   ‘multiArray3d<double>’ is not derived from ‘const tensor<T>’
                  vol_.Slice(ig1, ig1, jp, jp, kmin, kmax)));
                                                          ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2905:58: note:   ‘multiArray3d<double>’ is not derived from ‘const unitVec3dMag<T>’
                  vol_.Slice(ig1, ig1, jp, jp, kmin, kmax)));
                                                          ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2905:58: note:   ‘multiArray3d<double>’ is not derived from ‘const vector3d<T>’
                  vol_.Slice(ig1, ig1, jp, jp, kmin, kmax)));
                                                          ^
procBlock.cpp:2910:53: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<double>’)
     vol_.Insert(ig2, ig2, jg2, jg2, kmin, kmax, 0.5 *
                                                     ^
procBlock.cpp:2910:53: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2912:60: note:   ‘multiArray3d<double>’ is not derived from ‘const tensor<T>’
                  vol_.Slice(ig2, ig2, jg1, jg1, kmin, kmax)));
                                                            ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2912:60: note:   ‘multiArray3d<double>’ is not derived from ‘const unitVec3dMag<T>’
                  vol_.Slice(ig2, ig2, jg1, jg1, kmin, kmax)));
                                                            ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2912:60: note:   ‘multiArray3d<double>’ is not derived from ‘const vector3d<T>’
                  vol_.Slice(ig2, ig2, jg1, jg1, kmin, kmax)));
                                                            ^
procBlock.cpp:2915:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaI_.Insert(ig1F, ig1F, jg1, jg1, kmin, kmax, 0.5 *
                                                          ^
procBlock.cpp:2915:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2917:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaI_.Slice(ig1F, ig1F, jp, jp, kmin, kmax)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2917:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaI_.Slice(ig1F, ig1F, jp, jp, kmin, kmax)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2917:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaI_.Slice(ig1F, ig1F, jp, jp, kmin, kmax)));
                                                                  ^
procBlock.cpp:2918:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaJ_.Insert(ig1, ig1, jg1F, jg1F, kmin, kmax, 0.5 *
                                                          ^
procBlock.cpp:2918:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2920:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaJ_.Slice(ig1, ig1, jpF, jpF, kmin, kmax)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2920:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaJ_.Slice(ig1, ig1, jpF, jpF, kmin, kmax)));
                                                                  ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2920:66: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaJ_.Slice(ig1, ig1, jpF, jpF, kmin, kmax)));
                                                                  ^
procBlock.cpp:2921:57: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaK_.Insert(ig1, ig1, jg1, jg1, kmin, kmaxF, 0.5 *
                                                         ^
procBlock.cpp:2921:57: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2923:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaK_.Slice(ig1, ig1, jp, jp, kmin, kmaxF)));
                                                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2923:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaK_.Slice(ig1, ig1, jp, jp, kmin, kmaxF)));
                                                                 ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2923:65: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaK_.Slice(ig1, ig1, jp, jp, kmin, kmaxF)));
                                                                 ^
procBlock.cpp:2939:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaI_.Insert(ig2F, ig2F, jg2, jg2, kmin, kmax, 0.5 *
                                                          ^
procBlock.cpp:2939:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2941:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaI_.Slice(ig2F, ig2F, jg1, jg1, kmin, kmax)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2941:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaI_.Slice(ig2F, ig2F, jg1, jg1, kmin, kmax)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2941:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaI_.Slice(ig2F, ig2F, jg1, jg1, kmin, kmax)));
                                                                    ^
procBlock.cpp:2942:58: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaJ_.Insert(ig2, ig2, jg2F, jg2F, kmin, kmax, 0.5 *
                                                          ^
procBlock.cpp:2942:58: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2944:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaJ_.Slice(ig2, ig2, jg1F, jg1F, kmin, kmax)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2944:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaJ_.Slice(ig2, ig2, jg1F, jg1F, kmin, kmax)));
                                                                    ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2944:68: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaJ_.Slice(ig2, ig2, jg1F, jg1F, kmin, kmax)));
                                                                    ^
procBlock.cpp:2945:57: error: no match for ‘operator*’ (operand types are ‘double’ and ‘multiArray3d<unitVec3dMag<double> >’)
     fAreaK_.Insert(ig2, ig2, jg2, jg2, kmin, kmaxF, 0.5 *
                                                         ^
procBlock.cpp:2945:57: note: candidates are:
In file included from procBlock.hpp:28:0,
                 from procBlock.cpp:23:
tensor.hpp:289:12: note: template<class TT> tensor<T> operator*(const TT&, const tensor<T>&)
 tensor<TT> operator*(const TT &scalar, const tensor<TT> &v1) {
            ^
tensor.hpp:289:12: note:   template argument deduction/substitution failed:
procBlock.cpp:2947:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const tensor<T>’
                     fAreaK_.Slice(ig2, ig2, jg1, jg1, kmin, kmaxF)));
                                                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:296:18: note: template<class TT> unitVec3dMag<T> operator*(const TT&, const unitVec3dMag<T>&)
 unitVec3dMag<TT> operator*(const TT &scalar, const unitVec3dMag<TT> &v1) {
                  ^
vector3d.hpp:296:18: note:   template argument deduction/substitution failed:
procBlock.cpp:2947:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const unitVec3dMag<T>’
                     fAreaK_.Slice(ig2, ig2, jg1, jg1, kmin, kmaxF)));
                                                                   ^
In file included from procBlock.hpp:26:0,
                 from procBlock.cpp:23:
vector3d.hpp:163:14: note: template<class TT> vector3d<T> operator*(const TT&, const vector3d<T>&)
 vector3d<TT> operator*(const TT &scalar, const vector3d<TT> &v1) {
              ^
vector3d.hpp:163:14: note:   template argument deduction/substitution failed:
procBlock.cpp:2947:67: note:   ‘multiArray3d<unitVec3dMag<double> >’ is not derived from ‘const vector3d<T>’
                     fAreaK_.Slice(ig2, ig2, jg1, jg1, kmin, kmaxF)));
                                                                   ^
procBlock.cpp: In member function ‘void procBlock::AssignInviscidGhostCellsEdge(const input&, const idealGas&, const sutherland&)’:
procBlock.cpp:3272:9: warning: unused variable ‘imaxF’ [-Wunused-variable]
     int imaxF = this->NumI() + numGhosts_ + 1;
         ^
procBlock.cpp:3275:9: warning: unused variable ‘jiF’ [-Wunused-variable]
     int jiF = (cc <= 1) ? jp + 1 : jp - 1;
         ^
procBlock.cpp:3276:9: warning: unused variable ‘jg1F’ [-Wunused-variable]
     int jg1F = (cc <= 1) ? jp - 1 : jp + 1;
         ^
procBlock.cpp:3277:9: warning: unused variable ‘jg2F’ [-Wunused-variable]
     int jg2F = (cc <= 1) ? jp - 2 : jp + 2;
         ^
procBlock.cpp:3280:9: warning: unused variable ‘kg1F’ [-Wunused-variable]
     int kg1F = (cc % 2 == 0) ? kp - 1 : kp + 1;
         ^
procBlock.cpp:3281:9: warning: unused variable ‘kg2F’ [-Wunused-variable]
     int kg2F = (cc % 2 == 0) ? kp - 2 : kp + 2;
         ^
procBlock.cpp:3355:9: warning: unused variable ‘jmaxF’ [-Wunused-variable]
     int jmaxF = this->NumJ() + numGhosts_ + 1;
         ^
procBlock.cpp:3358:9: warning: unused variable ‘iiF’ [-Wunused-variable]
     int iiF = (cc <= 1) ? ip + 1 : ip - 1;
         ^
procBlock.cpp:3359:9: warning: unused variable ‘ig1F’ [-Wunused-variable]
     int ig1F = (cc <= 1) ? ip - 1 : ip + 1;
         ^
procBlock.cpp:3360:9: warning: unused variable ‘ig2F’ [-Wunused-variable]
     int ig2F = (cc <= 1) ? ip - 2 : ip + 2;
         ^
procBlock.cpp:3363:9: warning: unused variable ‘kg1F’ [-Wunused-variable]
     int kg1F = (cc % 2 == 0) ? kp - 1 : kp + 1;
         ^
procBlock.cpp:3364:9: warning: unused variable ‘kg2F’ [-Wunused-variable]
     int kg2F = (cc % 2 == 0) ? kp - 2 : kp + 2;
         ^
procBlock.cpp:3438:9: warning: unused variable ‘kmaxF’ [-Wunused-variable]
     int kmaxF = this->NumK() + numGhosts_ + 1;
         ^
procBlock.cpp:3441:9: warning: unused variable ‘iiF’ [-Wunused-variable]
     int iiF = (cc <= 1) ? ip + 1 : ip - 1;
         ^
procBlock.cpp:3442:9: warning: unused variable ‘ig1F’ [-Wunused-variable]
     int ig1F = (cc <= 1) ? ip - 1 : ip + 1;
         ^
procBlock.cpp:3443:9: warning: unused variable ‘ig2F’ [-Wunused-variable]
     int ig2F = (cc <= 1) ? ip - 2 : ip + 2;
         ^
procBlock.cpp:3446:9: warning: unused variable ‘jg1F’ [-Wunused-variable]
     int jg1F = (cc % 2 == 0) ? jp - 1 : jp + 1;
         ^
procBlock.cpp:3447:9: warning: unused variable ‘jg2F’ [-Wunused-variable]
     int jg2F = (cc % 2 == 0) ? jp - 2 : jp + 2;
         ^
procBlock.cpp: In member function ‘void procBlock::AssignViscousGhostCellsEdge(const input&, const idealGas&, const sutherland&)’:
procBlock.cpp:3734:9: warning: unused variable ‘imaxF’ [-Wunused-variable]
     int imaxF = this->NumI() + numGhosts_ + 1;
         ^
procBlock.cpp:3737:9: warning: unused variable ‘jiF’ [-Wunused-variable]
     int jiF = (cc <= 1) ? jp + 1 : jp - 1;
         ^
procBlock.cpp:3738:9: warning: unused variable ‘jg1F’ [-Wunused-variable]
     int jg1F = (cc <= 1) ? jp - 1 : jp + 1;
         ^
procBlock.cpp:3739:9: warning: unused variable ‘jg2F’ [-Wunused-variable]
     int jg2F = (cc <= 1) ? jp - 2 : jp + 2;
         ^
procBlock.cpp:3742:9: warning: unused variable ‘kg1F’ [-Wunused-variable]
     int kg1F = (cc % 2 == 0) ? kp - 1 : kp + 1;
         ^
procBlock.cpp:3743:9: warning: unused variable ‘kg2F’ [-Wunused-variable]
     int kg2F = (cc % 2 == 0) ? kp - 2 : kp + 2;
         ^
procBlock.cpp:3817:9: warning: unused variable ‘jmaxF’ [-Wunused-variable]
     int jmaxF = this->NumJ() + numGhosts_ + 1;
         ^
procBlock.cpp:3820:9: warning: unused variable ‘iiF’ [-Wunused-variable]
     int iiF = (cc <= 1) ? ip + 1 : ip - 1;
         ^
procBlock.cpp:3821:9: warning: unused variable ‘ig1F’ [-Wunused-variable]
     int ig1F = (cc <= 1) ? ip - 1 : ip + 1;
         ^
procBlock.cpp:3822:9: warning: unused variable ‘ig2F’ [-Wunused-variable]
     int ig2F = (cc <= 1) ? ip - 2 : ip + 2;
         ^
procBlock.cpp:3825:9: warning: unused variable ‘kg1F’ [-Wunused-variable]
     int kg1F = (cc % 2 == 0) ? kp - 1 : kp + 1;
         ^
procBlock.cpp:3826:9: warning: unused variable ‘kg2F’ [-Wunused-variable]
     int kg2F = (cc % 2 == 0) ? kp - 2 : kp + 2;
         ^
procBlock.cpp:3900:9: warning: unused variable ‘kmaxF’ [-Wunused-variable]
     int kmaxF = this->NumK() + numGhosts_ + 1;
         ^
procBlock.cpp:3903:9: warning: unused variable ‘iiF’ [-Wunused-variable]
     int iiF = (cc <= 1) ? ip + 1 : ip - 1;
         ^
procBlock.cpp:3904:9: warning: unused variable ‘ig1F’ [-Wunused-variable]
     int ig1F = (cc <= 1) ? ip - 1 : ip + 1;
         ^
procBlock.cpp:3905:9: warning: unused variable ‘ig2F’ [-Wunused-variable]
     int ig2F = (cc <= 1) ? ip - 2 : ip + 2;
         ^
procBlock.cpp:3908:9: warning: unused variable ‘jg1F’ [-Wunused-variable]
     int jg1F = (cc % 2 == 0) ? jp - 1 : jp + 1;
         ^
procBlock.cpp:3909:9: warning: unused variable ‘jg2F’ [-Wunused-variable]
     int jg2F = (cc % 2 == 0) ? jp - 2 : jp + 2;
         ^
procBlock.cpp: In member function ‘procBlock procBlock::Split(const string&, const int&, const int&, std::vector<boundarySurface>&)’:
procBlock.cpp:5839:17: error: ‘numI_’ was not declared in this scope
     int numI2 = numI_ - ind;
                 ^
procBlock.cpp:5842:27: error: ‘numJ_’ was not declared in this scope
     procBlock blk1(numI1, numJ_, numK_, numGhosts_);
                           ^
procBlock.cpp:5842:34: error: ‘numK_’ was not declared in this scope
     procBlock blk1(numI1, numJ_, numK_, numGhosts_);
                                  ^
procBlock.cpp:5948:17: error: ‘numJ_’ was not declared in this scope
     int numJ2 = numJ_ - ind;
                 ^
procBlock.cpp:5951:20: error: ‘numI_’ was not declared in this scope
     procBlock blk1(numI_, numJ1, numK_, numGhosts_);
                    ^
procBlock.cpp:5951:34: error: ‘numK_’ was not declared in this scope
     procBlock blk1(numI_, numJ1, numK_, numGhosts_);
                                  ^
procBlock.cpp:6057:17: error: ‘numK_’ was not declared in this scope
     int numK2 = numK_ - ind;
                 ^
procBlock.cpp:6060:20: error: ‘numI_’ was not declared in this scope
     procBlock blk1(numI_, numJ_, numK1, numGhosts_);
                    ^
procBlock.cpp:6060:27: error: ‘numJ_’ was not declared in this scope
     procBlock blk1(numI_, numJ_, numK1, numGhosts_);
                           ^
procBlock.cpp: In member function ‘void procBlock::Join(const procBlock&, const string&, std::vector<boundarySurface>&)’:
procBlock.cpp:6182:16: error: ‘numI_’ was not declared in this scope
     int iMax = numI_ + blk.numI_;
                ^
procBlock.cpp:6182:28: error: ‘const class procBlock’ has no member named ‘numI_’
     int iMax = numI_ + blk.numI_;
                            ^
procBlock.cpp:6183:16: error: ‘numJ_’ was not declared in this scope
     int jMax = numJ_;
                ^
procBlock.cpp:6184:16: error: ‘numK_’ was not declared in this scope
     int kMax = numK_;
                ^
procBlock.cpp:6195:22: error: ‘const class procBlock’ has no member named ‘numI_’
     int iMaxUG = blk.numI_ + 2 * blk.numGhosts_;
                      ^
procBlock.cpp:6196:21: error: ‘const class procBlock’ has no member named ‘numI_’
     int iMaxU = blk.numI_;
                     ^
procBlock.cpp:6279:16: error: ‘numI_’ was not declared in this scope
     int iMax = numI_;
                ^
procBlock.cpp:6280:16: error: ‘numJ_’ was not declared in this scope
     int jMax = numJ_ + blk.numJ_;
                ^
procBlock.cpp:6280:28: error: ‘const class procBlock’ has no member named ‘numJ_’
     int jMax = numJ_ + blk.numJ_;
                            ^
procBlock.cpp:6281:16: error: ‘numK_’ was not declared in this scope
     int kMax = numK_;
                ^
procBlock.cpp:6292:22: error: ‘const class procBlock’ has no member named ‘numJ_’
     int jMaxUG = blk.numJ_ + 2 * blk.numGhosts_;
                      ^
procBlock.cpp:6293:21: error: ‘const class procBlock’ has no member named ‘numJ_’
     int jMaxU = blk.numJ_;
                     ^
procBlock.cpp:6376:16: error: ‘numI_’ was not declared in this scope
     int iMax = numI_;
                ^
procBlock.cpp:6377:16: error: ‘numJ_’ was not declared in this scope
     int jMax = numJ_;
                ^
procBlock.cpp:6378:16: error: ‘numK_’ was not declared in this scope
     int kMax = numK_ + blk.numK_;
                ^
procBlock.cpp:6378:28: error: ‘const class procBlock’ has no member named ‘numK_’
     int kMax = numK_ + blk.numK_;
                            ^
procBlock.cpp:6389:22: error: ‘const class procBlock’ has no member named ‘numK_’
     int kMaxUG = blk.numK_ + 2 * blk.numGhosts_;
                      ^
procBlock.cpp:6390:21: error: ‘const class procBlock’ has no member named ‘numK_’
     int kMaxU = blk.numK_;
                     ^
procBlock.cpp:6441:69: error: ‘jMaxU’ was not declared in this scope
                                 blk.avgWaveSpeed_.Slice(0, iMax, 0, jMaxU, 0,
                                                                     ^
procBlock.cpp:6390:9: warning: unused variable ‘kMaxU’ [-Wunused-variable]
     int kMaxU = blk.numK_;
         ^
procBlock.cpp: In member function ‘void procBlock::CalcSrcTerms(const gradients&, const sutherland&, const turbModel*)’:
procBlock.cpp:6872:38: error: ‘loc’ was not declared in this scope
         src.CalcTurbSrc(turb, state_(loc), grads, suth,
                                      ^
In file included from procBlock.hpp:27:0,
                 from procBlock.cpp:23:
multiArray3d.hpp: In instantiation of ‘multiArray3d<T> multiArray3d<T>::operator-(const multiArray3d<T>&) const [with T = vector3d<double>]’:
procBlock.cpp:2282:61:   required from here
multiArray3d.hpp:213:19: error: no match for ‘operator-=’ (operand types are ‘__gnu_cxx::__alloc_traits<std::allocator<vector3d<double> > >::value_type {aka vector3d<double>}’ and ‘const value_type {aka const vector3d<double>}’)
     arr.data_[ii] -= b.data_[ii];
                   ^
multiArray3d.hpp: In instantiation of ‘multiArray3d<T> multiArray3d<T>::operator+(const multiArray3d<T>&) const [with T = vector3d<double>]’:
procBlock.cpp:2291:24:   required from here
multiArray3d.hpp:203:19: error: no match for ‘operator+=’ (operand types are ‘__gnu_cxx::__alloc_traits<std::allocator<vector3d<double> > >::value_type {aka vector3d<double>}’ and ‘const value_type {aka const vector3d<double>}’)
     arr.data_[ii] += b.data_[ii];
                   ^
multiArray3d.hpp: In instantiation of ‘multiArray3d<T> multiArray3d<T>::operator+(const multiArray3d<T>&) const [with T = unitVec3dMag<double>]’:
procBlock.cpp:2657:64:   required from here
multiArray3d.hpp:203:19: error: no match for ‘operator+=’ (operand types are ‘__gnu_cxx::__alloc_traits<std::allocator<unitVec3dMag<double> > >::value_type {aka unitVec3dMag<double>}’ and ‘const value_type {aka const unitVec3dMag<double>}’)
make: *** [procBlock.o] Error 1
